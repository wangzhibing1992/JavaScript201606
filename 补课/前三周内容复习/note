1.函数封装技巧和回调函数关注点：
公有的方法都封装在原型prototype上
    1.关于封装方法的思考技巧：
     * 1.作用：实现系统内置的forEach(); --prototype , this -实例
     * 2.是否有参数，有几个参数？ callback，context
     * 3.高级浏览器和低级浏览器各自的兼容性
     * 4.myforEach() 没有返回值；

    2.回调函数需要关注的4点：
     * 1.回调函数执行次数和this这个实例的长度有关；
     * 2.回调函数是否传参，有3个参数
     * 3.this指向--可以通过call,apply来修改this指向
     * 4.返回值
2.原型和原型链
1）为了解决全局变量冲突的问题--单例模式
var name='234';
var person1={
    name:function(){}，
    age:8,
}
var person2={
    age2:person1.age,
}
单例模式优点：
1.可以进行模块化开发
2.本模块之间相互调用 this.属性名
3.模块之间相互调用 模块名.属性名
单例模式缺点：传统的手工作业模式，开发效率低，存在大量冗余代码；
解决问题：--工厂模式
2）工厂模式：
    1.创建一个对象
    2.给对象添加属性和方法
    3.输出对象 return object；
工厂模式优点：封装
缺点：不能做为一个类，去创建更多的实例；
解决问题：--构造函数
3）构造函数和工作模式的区别：
    1.在函数调用时；
    工厂模式：person();
    构造函数：new Person();
    2.在函数内部不同：
    工厂模式：1.创建一个对象；2.给对象添加属性和方法；3.输出对象 return object；
    构造函数：1.系统自动创建对象 this 2.给对象添加属性和方法； 3.系统自动输出对象；
4）为何要用构造函数：自定义一个类，同时，让这个类可以创建很多实例；
构造函数存在一个问题：构造函数中所有的属性和方法都是私有的；
我们为了让所有的实例都可以使用一套方法，就可以让方法放在原型上；
5）构造函数的原型模式：重中之重3句话
    1）每一个函数数据（普通函数，类）类型上都天生自带一个属性prototype，它是一个对象；
    2）这个对象prototype上，都天生自带一个属性constructor：构造函数 或 类
    3）每一个对象（prototype，普通，实例）上，都自带一个属性__proto__，他指向当前实例所属类的原型；
4.this总结：
1）当触发元素身上的事件执行一个方法的时候，方法中的this指向当前这个元素
2）自执行函数中的this永远都是window；
3）构造函数中的this-实例
4）遇到call,apply,bind以上规则都失效，因为他们的第一个参数可以改变this指向
5）回调函数中的this，一般都是window；
6)当函数执行的时候，点前面是谁，this就是谁；
5.原型继承
    1.原型链继承:把父类上公有+私有的属性和方法都作为子类公有的；
    2.call继承：把父类私有的属性和方法作为子类私有；
    3.冒充继承：把父类上公有+私有的属性和方法都作为子类私有的；
    4.混合继承： call继承+原型链继承
    问题：父类上私有的属性和方法同时在子类私有和公有上；
    5.混合继承： call继承+拷贝继承for in
    6.寄生式组合继承： call继承+Object.create()思想；
6.预解释
  在当前作用域下，在JS代码执行之前，浏览器会对带var和带function进行提前声明或定义
  带var：只声明，不定义
  带function：声明+定义
5.预解释无节操：
  1）自执行函数不要预解释，执行到的时候，声明+定义+调用同步完成
  2）只对=左边带var ,进行声明不定义
  3）if语句无论条件是否成立都会进行预解释
  4）return返回值不会进行预解释，但是return下面的语句虽然不执行，但会进行预解释
  5）已经声明过的变量，不会进行重复声明，但会重新赋值
6.作用域链：
  原型链：
7.带var 和 不带var的区别
    带var ：1）会预解释 2）如果是全局变量--全局属性
    不带var:1)不会预解释 2）全局属性
8.上级作用域：跟函数调用没有关系，只跟函数对应的堆内存在哪里开辟有关；




























